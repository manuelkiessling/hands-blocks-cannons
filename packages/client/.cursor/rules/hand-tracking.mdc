---
description: MediaPipe hand tracking integration patterns
globs: ["**/input/**/*.ts"]
---

# Hand Tracking Integration

## MediaPipe Setup

MediaPipe is loaded via CDN in `index.html`:

```html
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>
```

## Hand Landmarks

MediaPipe provides 21 landmarks per hand:

```
        8   12  16  20      <- Fingertips
        |   |   |   |
        7   11  15  19
        |   |   |   |
        6   10  14  18
        |   |   |   |
        5---9---13--17
         \  |  /   /
          \ | /   /
           \|/   /
    4       0---/           <- Wrist (0)
    |      /
    3     /
    |    /
    2   /                   <- Thumb
    |  /
    1 /
```

Key indices (from `constants.ts`):
- `WRIST: 0`
- `THUMB_TIP: 4`
- `INDEX_TIP: 8`

## Gesture Detection

### Pinch Detection

Pinch is detected by measuring distance between thumb and index fingertips:

```typescript
isPinching(landmarks: HandLandmarks): boolean {
  const thumb = landmarks[HAND_LANDMARKS.THUMB_TIP];
  const index = landmarks[HAND_LANDMARKS.INDEX_TIP];
  
  const dist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
  return dist < PINCH_THRESHOLD; // 0.07 normalized
}
```

### Pinch Point

The interaction point is the midpoint between thumb and index:

```typescript
getPinchPoint(landmarks: HandLandmarks): THREE.Vector3 {
  return landmarkTo3D({
    x: (thumb.x + index.x) / 2,
    y: (thumb.y + index.y) / 2,
    z: 0,
  });
}
```

## Coordinate Mapping

### Normalized to World Space

Landmarks are in normalized space (0-1). Map to game world:

```typescript
landmarkTo3D(lm: { x: number; y: number }): THREE.Vector3 {
  // Account for camera margin
  const normX = (lm.x - CAMERA_MARGIN) / (1 - 2 * CAMERA_MARGIN);
  const normY = (lm.y - CAMERA_MARGIN) / (1 - 2 * CAMERA_MARGIN);
  
  // Clamp to 0-1
  const clampedX = Math.max(0, Math.min(1, normX));
  const clampedY = Math.max(0, Math.min(1, normY));
  
  // Mirror X for Player 1 (webcam is mirrored)
  const mappedX = playerNumber === 1 ? 1 - clampedX : clampedX;
  
  // Map to room bounds
  const x = mappedX * (room.maxX - room.minX) + room.minX;
  const y = (1 - clampedY) * (room.maxY - room.minY) + room.minY;
  const z = playerNumber === 1 ? room.maxZ - 0.5 : room.minZ + 0.5;
  
  return new THREE.Vector3(x, y, z);
}
```

## Boundary Detection

Track when hand is near or outside camera bounds:

```typescript
type HandState = 'normal' | 'warning' | 'outside';

getHandState(landmarks: HandLandmarks): HandState {
  const wrist = landmarks[0];
  
  const nearEdge = wrist.x < CAMERA_MARGIN + EDGE_THRESHOLD ||
                   wrist.x > 1 - CAMERA_MARGIN - EDGE_THRESHOLD;
  
  const outside = wrist.x < CAMERA_MARGIN ||
                  wrist.x > 1 - CAMERA_MARGIN;
  
  if (outside) return 'outside';
  if (nearEdge) return 'warning';
  return 'normal';
}
```

## Visual Feedback

### Hand Skeleton

Render a 3D skeleton matching the hand:

```typescript
// Update joint positions
for (let i = 0; i < 21; i++) {
  joints[i].position.copy(positions3D[i]);
  joints[i].visible = true;
}

// Update bones between joints
for (const [a, b] of BONE_CONNECTIONS) {
  bone.position.lerpVectors(positions3D[a], positions3D[b], 0.5);
  bone.scale.y = positions3D[a].distanceTo(positions3D[b]);
  bone.lookAt(positions3D[b]);
  bone.rotateX(Math.PI / 2);
}
```

### Color Feedback

Change hand color based on boundary state:

```typescript
const color = handState === 'outside' ? HAND_COLORS.OUTSIDE :
              handState === 'warning' ? HAND_COLORS.WARNING :
              HAND_COLORS.NORMAL;
```

## Async Initialization

MediaPipe loads asynchronously. Wait for it:

```typescript
private async waitForMediaPipe(): Promise<void> {
  return new Promise((resolve, reject) => {
    let attempts = 0;
    const check = () => {
      if (window.Hands && window.Camera) {
        resolve();
      } else if (attempts++ > 50) {
        reject(new Error('MediaPipe failed to load'));
      } else {
        setTimeout(check, 100);
      }
    };
    check();
  });
}
```

## Type Definitions

MediaPipe types are defined in `types.ts`:

```typescript
declare global {
  interface Window {
    Hands: new (config: { locateFile: (file: string) => string }) => MediaPipeHands;
    Camera: new (video: HTMLVideoElement, config: {...}) => MediaPipeCamera;
  }
}

interface MediaPipeResults {
  multiHandLandmarks?: HandLandmarks[];
}
```

## Error Handling

Handle camera access failures gracefully:

```typescript
try {
  const stream = await navigator.mediaDevices.getUserMedia({ video: {...} });
  // Success - start tracking
} catch (err) {
  // Show fallback UI
  statusDisplay.showFallback();
}
```
