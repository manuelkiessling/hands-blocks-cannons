---
description: Development standards for the block-game-server TypeScript project
globs: ["**/*.ts"]
---

# Server Development Standards

## TypeScript Strictness

This project uses maximum TypeScript strictness. The following compiler options are enforced:

- `strict: true` - All strict type checking options
- `noUncheckedIndexedAccess: true` - Array/object indexing returns `T | undefined`
- `noImplicitReturns: true` - All code paths must return
- `noFallthroughCasesInSwitch: true` - No fallthrough in switch statements
- `exactOptionalPropertyTypes: true` - Optional properties cannot be assigned `undefined` unless explicitly typed
- `noPropertyAccessFromIndexSignature: true` - Use bracket notation for index signatures

**Never use:**
- `any` type (use `unknown` and narrow with type guards)
- Non-null assertions (`!`) - use proper null checks or throw errors
- Type assertions (`as`) unless absolutely necessary with a comment explaining why

## Code Quality Tools

Before committing, always run:
```bash
npm run validate
```

This runs:
1. `tsc --noEmit` - Type checking
2. `biome check --write .` - Linting and formatting
3. `vitest run` - All tests

## Immutable Patterns

State classes (like `GameState`) must be immutable:
- All properties should be `readonly`
- Methods that "change" state return a new instance
- Never mutate existing state objects
- Use `ReadonlyMap`, `ReadonlyArray`, `Readonly<T>` for collections

```typescript
// GOOD
moveBlock(blockId: string, pos: Position): GameState {
  const newBlocks = new Map(this._blocks);
  newBlocks.set(blockId, { ...block, position: pos });
  return new GameState(newBlocks, this._players, this._config);
}

// BAD - mutates state
moveBlock(blockId: string, pos: Position): void {
  this._blocks.get(blockId).position = pos;
}
```

## Runtime Validation with Zod

All external data (WebSocket messages, API inputs) must be validated with Zod schemas:

```typescript
// Define schema
const BlockMoveMessage = z.object({
  type: z.literal('block_move'),
  blockId: z.string(),
  position: PositionSchema,
});

// Validate incoming data
const result = BlockMoveMessage.safeParse(data);
if (!result.success) {
  // Handle invalid data
}
```

## File Organization

```
src/
├── index.ts              # Entry point only - minimal code
├── server.ts             # Server setup
├── game/                 # Game logic (pure, testable)
│   ├── GameState.ts
│   ├── GameManager.ts
│   └── types.ts
├── protocol/             # Message handling
│   ├── messages.ts       # Zod schemas
│   └── handlers.ts       # Message processors
└── utils/                # Shared utilities
    └── logger.ts
```

## Testing Requirements

- All game logic in `src/game/` must have corresponding tests
- Tests go in `tests/` directory with `.test.ts` suffix
- Use descriptive test names that explain the behavior
- Test edge cases and error conditions
- Avoid non-null assertions in tests - use helper functions that throw on missing data

## Error Handling

- Use explicit error handling, not exceptions for control flow
- Return `Result` types or use discriminated unions for operations that can fail
- Log errors with structured data using the logger utility
- Never swallow errors silently

## Biome Rules

Key rules enforced by Biome:
- `noExplicitAny` - Forbidden
- `noNonNullAssertion` - Forbidden
- `useConst` - Required for non-reassigned variables
- `noUnusedImports` - Error
- `noUnusedVariables` - Error

If you must bypass a rule, use the ignore comment with explanation:
```typescript
// biome-ignore lint/ruleName: Explanation why this is necessary
```
